---
phase: 03-transpilation
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/lib/transpilation/transformer.ts
  - src/lib/transpilation/emitter.ts
  - src/lib/transpilation/transform-rules.json
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "CLI transforms IR into valid OpenCode JSON configuration"
    - "CLI uses config-driven mapping rules (not hardcoded)"
    - "CLI tracks approximations when GSD concept has no OpenCode equivalent"
    - "Transform rules can be overridden by user via ~/.gfh/transforms.json"
  artifacts:
    - path: "src/lib/transpilation/transformer.ts"
      provides: "IR to OpenCode transformation logic"
      exports: ["transformToOpenCode", "TransformResult"]
      min_lines: 120
    - path: "src/lib/transpilation/emitter.ts"
      provides: "OpenCode JSON emission with formatting"
      exports: ["emitOpenCodeConfig", "EmitResult"]
      min_lines: 80
    - path: "src/lib/transpilation/transform-rules.json"
      provides: "Default transform mapping rules"
      contains: "agents"
    - path: "src/types/index.ts"
      provides: "Transform and emit result types"
      contains: "TransformResult"
  key_links:
    - from: "src/lib/transpilation/transformer.ts"
      to: "src/lib/transpilation/ir-types.ts"
      via: "IR type imports"
      pattern: "import.*GSDIntermediate"
    - from: "src/lib/transpilation/transformer.ts"
      to: "src/lib/transpilation/transform-rules.json"
      via: "load mapping rules"
      pattern: "import.*transform-rules"
    - from: "src/lib/transpilation/emitter.ts"
      to: "node:fs/promises"
      via: "JSON file generation"
      pattern: "JSON\\.stringify"
---

<objective>
Build the transformation engine that converts the intermediate representation (IR) into valid OpenCode JSON configuration using config-driven mapping rules.

Purpose: Separate transformation logic from both parsing (Plan 1) and file operations (Plan 3). Enable user customization of transform rules. Track gaps when GSD concepts don't map to OpenCode.

Output: Working transformer with default mapping rules and comprehensive gap tracking.
</objective>

<execution_context>
@C:\Users\Terence\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Terence\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning\PROJECT.md
@.planning\ROADMAP.md
@.planning\STATE.md
@.planning\REQUIREMENTS.md
@.planning\phases\03-transpilation\03-CONTEXT.md
@.planning\phases\03-transpilation\03-RESEARCH.md

# Existing codebase
@src\types\index.ts
@src\lib\logger.ts
@src\lib\paths.ts
@package.json

# From Plan 1 (Wave 1 - completed)
# IR types available from ir-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create default transform rules</name>
  <files>src/lib/transpilation/transform-rules.json</files>
  <action>
Create JSON file defining default GSD → OpenCode mapping rules.

Structure:
```json
{
  "version": "1.0",
  "agents": {
    "fieldMappings": {
      "name": "name",
      "model": "model",
      "temperature": "temperature",
      "systemPrompt": "systemMessage"
    },
    "defaults": {
      "temperature": 0.7
    },
    "approximations": {
      "tools": "Mapped to OpenCode tools array if available"
    }
  },
  "commands": {
    "fieldMappings": {
      "name": "name",
      "description": "description",
      "template": "promptTemplate"
    },
    "approximations": {
      "variables": "Inlined into promptTemplate as template literals"
    }
  },
  "models": {
    "fieldMappings": {
      "name": "modelId",
      "provider": "provider"
    }
  },
  "config": {
    "fieldMappings": {
      "theme": "theme",
      "keybindings": "keybindings"
    },
    "approximations": {
      "permissions": "Not supported by OpenCode - logged as gap"
    }
  }
}
```

Add comments in JSON (if format allows) explaining:
- `fieldMappings`: Direct 1:1 field name mappings
- `defaults`: Values to use if GSD field is missing
- `approximations`: How to handle when GSD concept has no direct OpenCode equivalent

This file ships with the package. Users can override by creating `~/.gfh/transforms.json` with same structure.

Why JSON for rules: Readable, editable by users without code changes, version-controlled separately from logic.
  </action>
  <verify>
- `src/lib/transpilation/transform-rules.json` exists and is valid JSON
- File contains mappings for agents, commands, models, config
- Structure includes fieldMappings, defaults, approximations for each section
  </verify>
  <done>
Default transform rules defined in JSON. File is valid and contains all required mappings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement transformer</name>
  <files>src/lib/transpilation/transformer.ts, src/types/index.ts</files>
  <action>
Create transformer that converts GSDIntermediate to OpenCode configuration structure.

Transformer should:
1. Load transform rules:
   - Try `~/.gfh/transforms.json` first (user override)
   - Fall back to `src/lib/transpilation/transform-rules.json` (defaults)
   - Merge user overrides with defaults (user rules take precedence)
2. Transform each IR section:
   - **Agents**: Map GSDAgent[] → OpenCode agents config using fieldMappings
   - **Commands**: Map GSDCommand[] → OpenCode commands/prompts config
   - **Models**: Map GSDModel[] → OpenCode models config
   - **Config**: Map GSDConfig → OpenCode settings
3. Track gaps:
   - When field has no mapping, add to `gaps.unmappedFields[]`
   - When approximation is used, add to `gaps.approximations[]` with reason
   - Example: `{ original: "GSD.permissions", approximatedAs: "none", reason: "OpenCode does not support permissions" }`
4. Return `TransformResult`:
   ```typescript
   interface TransformResult {
     success: boolean;
     opencode?: OpenCodeConfig;
     errors: Array<{ message: string; stack?: string }>;
     warnings: string[];
     gaps: {
       unmappedFields: string[];
       approximations: Array<{ original: string; approximatedAs: string; reason: string }>;
     };
   }
   ```

`OpenCodeConfig` structure (based on OpenCode docs):
```typescript
interface OpenCodeConfig {
  agents: Array<{
    name: string;
    model: string;
    temperature?: number;
    systemMessage: string;
    tools?: string[];
  }>;
  commands: Array<{
    name: string;
    description: string;
    promptTemplate: string;
  }>;
  models: Array<{
    modelId: string;
    provider: string;
    config?: Record<string, any>;
  }>;
  settings: {
    theme?: string;
    keybindings?: Record<string, string>;
    [key: string]: any;
  };
}
```

Error handling:
- Continue on transform errors (add to errors[], return partial config)
- Validate required fields (name, model for agents; name for commands)
- Provide helpful messages: "Agent 'qa-agent' missing required field 'model'"

Use node:fs/promises to read transform rules. Use node:path to resolve `~/.gfh/transforms.json`.

Add `TransformResult` and `OpenCodeConfig` to src/types/index.ts.

Why separate transformer from emitter: Transformer is pure logic (IR → data structure). Emitter handles file formatting. Separation enables testing without filesystem.
  </action>
  <verify>
- `npm run build` compiles without errors
- Transformer exports `transformToOpenCode(ir: GSDIntermediate): Promise<TransformResult>`
- User override at `~/.gfh/transforms.json` is loaded if exists
- Gaps are tracked when approximations are used
- Transform errors include helpful messages
  </verify>
  <done>
Transformer implemented with config-driven rules. User overrides work. Gaps are tracked and reported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement emitter and add tests</name>
  <files>src/lib/transpilation/emitter.ts, src/lib/transpilation/transformer.test.ts</files>
  <action>
**Part 1: Create emitter**

Emitter converts OpenCodeConfig to formatted JSON strings ready for file write.

Emitter should:
1. Accept `OpenCodeConfig` structure
2. Generate OpenCode JSON files:
   - `agents.json`: agents array
   - `commands.json`: commands array
   - `models.json`: models array
   - `settings.json`: settings object
3. Format with `JSON.stringify(data, null, 2)` for readability
4. Sort all object keys for deterministic output (idempotency)
5. Return `EmitResult`:
   ```typescript
   interface EmitResult {
     success: boolean;
     files: Record<string, string>;  // filename → content
     errors: Array<{ message: string }>;
   }
   ```

Example `files` output:
```typescript
{
  "agents.json": "{\n  \"agents\": [...]\n}",
  "commands.json": "{\n  \"commands\": [...]\n}",
  ...
}
```

Why separate files: OpenCode convention is modular config files (not one large file). Easier for users to edit.

**Part 2: Create transformer tests**

Test cases:
1. **Happy path**: Mock IR with agents/commands/models, verify OpenCode structure is correct
2. **Field mappings**: Verify GSD fields map to OpenCode fields per transform-rules.json
3. **User overrides**: Mock `~/.gfh/transforms.json`, verify user rules override defaults
4. **Gaps tracking**: Mock IR with unmapped fields, verify gaps.unmappedFields is populated
5. **Approximations**: Mock IR requiring approximation, verify gaps.approximations has entry with reason
6. **Missing required fields**: Mock agent without model, verify error is added
7. **Deterministic output**: Transform same IR twice, verify emitted JSON is identical (string match)

Use Vitest. Mock fs for transform rules loading.

Add `EmitResult` to src/types/index.ts.
  </action>
  <verify>
- `npm run build` compiles without errors
- Emitter exports `emitOpenCodeConfig(config: OpenCodeConfig): EmitResult`
- Emitted JSON is formatted with 2-space indentation
- Object keys are sorted for determinism
- `npm test src/lib/transpilation/transformer.test.ts` passes all tests
- Tests verify mappings, user overrides, gap tracking, determinism
  </verify>
  <done>
Emitter implemented with formatted JSON output. Transformer tests pass. Gaps are tracked. User overrides work. Output is deterministic.
  </done>
</task>

</tasks>

<verification>
After all tasks:
- Transform rules are defined in `transform-rules.json`
- Transformer converts IR to OpenCodeConfig using rules
- User can override rules via `~/.gfh/transforms.json`
- Emitter generates formatted JSON files for OpenCode
- Gaps are tracked when approximations are used
- Tests verify mappings, overrides, gap tracking, determinism
- TypeScript compilation succeeds
- Tests pass
</verification>

<success_criteria>
1. Transformer uses config-driven rules (not hardcoded)
2. User overrides work via `~/.gfh/transforms.json`
3. Gaps are tracked when GSD concept has no OpenCode equivalent
4. Emitted JSON is formatted and deterministic
5. Tests verify transformation logic and gap tracking
</success_criteria>

<output>
After completion, create `.planning/phases/03-transpilation/03-02-SUMMARY.md`
</output>
