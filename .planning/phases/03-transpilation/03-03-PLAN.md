---
phase: 03-transpilation
plan: 03
type: execute
wave: 3
depends_on:
  - 03-01
  - 03-02
files_modified:
  - src/lib/transpilation/backup-manager.ts
  - src/lib/transpilation/idempotency.ts
  - src/lib/transpilation/orchestrator.ts
  - src/commands/transpile.ts
  - src/cli.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "CLI backs up existing OpenCode configs before overwrite (auto-backup without prompts per 03-CONTEXT.md design decision)"
    - "CLI writes all transpiled files or none (atomic operation)"
    - "CLI rolls back to backup if any write operation fails"
    - "CLI running transpilation twice produces identical results (idempotent)"
    - "CLI detects OpenCode config location automatically"
  artifacts:
    - path: "src/lib/transpilation/backup-manager.ts"
      provides: "Timestamped backup and rollback orchestration"
      exports: ["BackupManager", "BackupManifest"]
      min_lines: 150
    - path: "src/lib/transpilation/idempotency.ts"
      provides: "Content hashing and idempotency checking"
      exports: ["checkIdempotency", "hashDirectory"]
      min_lines: 60
    - path: "src/lib/transpilation/orchestrator.ts"
      provides: "Full transpilation pipeline orchestration"
      exports: ["runTranspilation", "TranspileOptions"]
      min_lines: 120
    - path: "src/commands/transpile.ts"
      provides: "CLI command for transpilation"
      exports: ["transpileCommand"]
      min_lines: 80
    - path: "src/cli.ts"
      provides: "CLI integration with transpile command"
      contains: "transpileCommand"
  key_links:
    - from: "src/lib/transpilation/orchestrator.ts"
      to: "src/lib/transpilation/parser.ts"
      via: "parse GSD files"
      pattern: "parseGSDFiles"
    - from: "src/lib/transpilation/orchestrator.ts"
      to: "src/lib/transpilation/transformer.ts"
      via: "transform IR"
      pattern: "transformToOpenCode"
    - from: "src/lib/transpilation/orchestrator.ts"
      to: "src/lib/transpilation/backup-manager.ts"
      via: "backup before write"
      pattern: "BackupManager.*backup"
    - from: "src/commands/transpile.ts"
      to: "src/lib/transpilation/orchestrator.ts"
      via: "run transpilation"
      pattern: "runTranspilation"
---

<objective>
Build the file operation layer that safely writes OpenCode configuration with backup, rollback, and idempotency guarantees. Orchestrate the full transpilation pipeline from GSD detection through file write.

Purpose: Ensure transpilation is safe (backups), atomic (all-or-nothing), and idempotent (re-runnable). Integrate parser + transformer into end-to-end CLI command.

Output: Complete transpilation system ready for user testing.
</objective>

<execution_context>
@C:\Users\Terence\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Terence\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning\PROJECT.md
@.planning\ROADMAP.md
@.planning\STATE.md
@.planning\REQUIREMENTS.md
@.planning\phases\03-transpilation\03-CONTEXT.md
@.planning\phases\03-transpilation\03-RESEARCH.md

# Existing codebase
@src\types\index.ts
@src\lib\logger.ts
@src\lib\paths.ts
@src\lib\exit-codes.ts
@src\cli.ts
@package.json

# From Plan 1 (Wave 1 - completed)
# Parser and IR types available

# From Plan 2 (Wave 2 - completed)
# Transformer, emitter, and transform rules available

# Phase 2 (Detection) outputs
# GSD detector and OpenCode detector available from Phase 2
@src\lib\detection\opencode-detector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backup manager</name>
  <files>src/lib/transpilation/backup-manager.ts, src/types/index.ts</files>
  <action>
Create BackupManager class for safe file operations with timestamped backups and rollback.

BackupManager should:
1. **Backup existing files**:
   - Create timestamped directory relative to OpenCode config directory: `<opencode-config-dir>/.opencode-backup/YYYY-MM-DD_HHMMSS/`
   - Copy each existing OpenCode config file to backup directory
   - Preserve directory structure within backup
   - Calculate SHA256 hash of each file (for verification)
   - Save file permissions (mode) for restoration
   - Create `manifest.json` with metadata:
     ```typescript
     interface BackupManifest {
       timestamp: string;  // ISO 8601
       source: string;     // GSD path that triggered backup
       files: Array<{
         path: string;
         hash: string;
         size: number;
         preserveMode?: number;
       }>;
     }
     ```
2. **Restore from backup**:
   - Read manifest.json from backup directory
   - For each file in manifest:
     - Verify backup file hash matches manifest
     - Restore content to original location
     - Restore file permissions
   - Log each restoration step
3. **List backups**:
   - Scan `.opencode-backup/` for timestamped directories
   - Return sorted list (newest first)

API:
```typescript
class BackupManager {
  constructor(configDir: string, logger: Logger);

  async backup(filePaths: string[]): Promise<string>;  // Returns backup path
  async restore(backupPath: string): Promise<void>;
  async listBackups(): Promise<string[]>;
}
```

Error handling:
- Throw on backup failure (caller handles rollback)
- Throw on restore failure with detailed message (which file, why)
- Log each step verbosely (for debugging)

Use node:fs/promises for async I/O. Use node:crypto for hashing. Use node:path for cross-platform paths.

Follow research Pattern 3 (Backup Manager). Reference research Example 2 (Backup and Rollback Pattern).

Add `BackupManifest` to src/types/index.ts.

Why timestamped backups: Users can restore any previous state. Multiple backups allow recovery from multiple transpilation attempts.
  </action>
  <verify>
- `npm run build` compiles without errors
- BackupManager exports class with backup(), restore(), listBackups()
- Backup creates timestamped directory with manifest.json
- Restore verifies hashes before restoring
- File permissions are preserved and restored
  </verify>
  <done>
BackupManager implemented with timestamped backups and manifest tracking. Restore includes hash verification. File permissions preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create idempotency checker and orchestrator</name>
  <files>src/lib/transpilation/idempotency.ts, src/lib/transpilation/orchestrator.ts, src/types/index.ts</files>
  <action>
**Part 1: Create idempotency module**

Idempotency checker tracks source content hash and detects if re-run is needed.

Module should:
1. **Hash directory**: Calculate SHA256 hash of all files in directory (sorted, deterministic)
2. **Check idempotency**: Compare current hash with last run in `.gfh-manifest.json`
3. **Write manifest**: Save transpilation metadata after successful run

Manifest structure:
```typescript
interface GFHManifest {
  version: "1.0";
  lastRun: {
    timestamp: string;
    sourceHash: string;    // SHA256 of GSD directory
    outputHash: string;    // SHA256 of generated OpenCode configs
    backup?: {
      location: string;
      timestamp: string;
    };
  };
  mappings: Array<{
    source: string;        // GSD file
    target: string;        // OpenCode config file
    transformed: boolean;
  }>;
}
```

API:
```typescript
export async function hashDirectory(dirPath: string): Promise<string>;
export async function checkIdempotency(gsdPath: string, manifestPath: string): Promise<{
  shouldRegenerate: boolean;
  reason?: string;
}>;
export async function writeManifest(manifest: GFHManifest, manifestPath: string): Promise<void>;
```

Follow research Pattern 4 (Idempotency). Reference research Example 3 (Idempotency Check).

**Part 2: Create orchestrator**

Orchestrator implements full transpilation pipeline (parse → transform → emit → write).

Pipeline:
1. **Check idempotency**: If source hash unchanged, skip (unless `--force` flag)
2. **Detect OpenCode config directory**:
   - Use `detectOpenCode()` from Phase 2's `src/lib/detection/opencode-detector.ts` to find OpenCode installation
   - Check standard config locations:
     - `~/.config/opencode` (Linux/Mac standard)
     - `%APPDATA%\opencode` (Windows standard)
     - Project root `.opencode/` (project-local)
   - If multiple found, prefer project-local, else prompt user
3. **Parse GSD files**: Call `parseGSDFiles(gsdPath)` from Plan 1
4. **Transform to OpenCode**: Call `transformToOpenCode(ir)` from Plan 2
5. **Emit JSON**: Call `emitOpenCodeConfig(config)` from Plan 2
6. **Backup existing configs**: Use BackupManager to backup existing OpenCode files
7. **Write new configs**: Write all emitted files atomically
8. **On error**: Restore backup via BackupManager, clean up partial writes
9. **On success**: Write `.gfh-manifest.json`, log backup location

Options:
```typescript
interface TranspileOptions {
  gsdPath: string;
  opencodeConfigDir?: string;  // Auto-detect if not provided
  dryRun: boolean;
  force: boolean;              // Skip idempotency check
  noBackup: boolean;           // Skip backup (dangerous)
}
```

Return:
```typescript
interface TranspileResult {
  success: boolean;
  backupLocation?: string;
  manifestPath?: string;
  errors: string[];
  warnings: string[];
  gaps?: GapsReport;
}
```

Error handling:
- Fail fast on critical errors (GSD not found, OpenCode dir not writable)
- Rollback all changes on any write error
- Log all steps verbosely (for debugging)
- Include stack traces in error messages

In `--dry-run` mode:
- Run full pipeline (parse, transform, emit)
- Validate write permissions (test write to OpenCode dir)
- Report what would be written
- Do NOT write files or create backups
- Follow research Example 4 (Dry-Run Full Validation)

Use @clack/prompts for OpenCode directory selection if multiple found.

Add `TranspileOptions`, `TranspileResult`, `GFHManifest` to src/types/index.ts.

Why atomic writes: Collect all emitted JSON in memory, then write all files. If any write fails, rollback restores all. No partial state.
  </action>
  <verify>
- `npm run build` compiles without errors
- Idempotency module exports hashDirectory, checkIdempotency, writeManifest
- Orchestrator exports runTranspilation(options: TranspileOptions): Promise<TranspileResult>
- Orchestrator uses Phase 2's detectOpenCode() for directory detection
- Orchestrator backs up before writing, rolls back on error
- Dry-run mode validates but doesn't write files
- Idempotency check skips re-run if source unchanged (unless --force)
  </verify>
  <done>
Idempotency checker implemented with content hashing. Orchestrator implements full pipeline with backup/rollback. Dry-run validates without writing. OpenCode directory auto-detection uses Phase 2's detector.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CLI command and integrate into main CLI</name>
  <files>src/commands/transpile.ts, src/cli.ts</files>
  <action>
**Part 1: Create transpile command**

Create `transpile` command that hooks into CLI and runs orchestrator.

Command should:
1. Use GSD detector from Phase 2 to find GSD installation
2. Prompt user if GSD not found or invalid
3. Build `TranspileOptions` from CLI flags (--dry-run, --force, --no-backup)
4. Call `runTranspilation(options)`
5. Report results:
   - Success: "Transpilation complete. Backup at: [path]. Manifest: [path]."
   - Warnings: "Transpilation succeeded with warnings: [list]"
   - Gaps: "Some GSD features couldn't be mapped: [list]. See manifest for details."
   - Errors: "Transpilation failed: [errors]"
6. Exit with appropriate code (EXIT_SUCCESS, EXIT_WARNING, EXIT_ERROR from exit-codes.ts)

Log levels:
- Quiet mode (`--quiet`): Only errors
- Normal: Success/error messages, backup location
- Verbose mode (`-v`): Full pipeline steps, file operations, timings

Handle signals:
- Ctrl+C during transpilation: Rollback, clean up, exit gracefully
- Use isCancel() from @clack/prompts for user cancellation

**Part 2: Integrate into main CLI**

Update `src/cli.ts`:
1. Import transpileCommand
2. Add `transpile` subcommand to Commander:
   ```typescript
   program
     .command('transpile')
     .description('Transpile GSD context to OpenCode configuration')
     .option('--force', 'Force re-transpilation even if source unchanged')
     .option('--no-backup', 'Skip backup of existing configs (dangerous)')
     .action(async (options) => {
       await transpileCommand(options, globalOptions);
     });
   ```
3. Pass global options (verbose, quiet, dryRun) to transpileCommand

Follow existing CLI patterns from Phase 1 (manifesto.ts, exit-codes.ts).

Why separate command file: Keeps cli.ts lean. Follows convention from Phase 2 detection modules.
  </action>
  <verify>
- `npm run build` compiles without errors
- `npm run dev transpile --help` shows transpile command help
- `npm run dev transpile --dry-run` validates without writing
- `npm run dev transpile --force` forces re-transpilation
- CLI reports backup location and manifest path on success
- CLI exits with appropriate codes (0 success, 1 warning, 2+ error)
- Ctrl+C during transpilation triggers rollback
  </verify>
  <done>
Transpile command implemented and integrated into CLI. Dry-run, force, and no-backup flags work. CLI reports backup location and exits with appropriate codes. Rollback on Ctrl+C works.
  </done>
</task>

</tasks>

<verification>
After all tasks:
- BackupManager creates timestamped backups with manifest in OpenCode config directory
- Idempotency checker detects unchanged source and skips re-run
- Orchestrator runs full pipeline (parse → transform → emit → write)
- Orchestrator backs up before writing, rolls back on error
- CLI `transpile` command integrates orchestrator
- Dry-run validates without writing files
- TypeScript compilation succeeds
- All flags (--force, --dry-run, --no-backup) work correctly
</verification>

<success_criteria>
1. Transpilation backs up existing configs before overwrite (auto-backup per context decision)
2. Transpilation is atomic (all files written or none)
3. Rollback restores from backup on any error
4. Running transpilation twice with same source produces identical results
5. CLI command is integrated and functional
</success_criteria>

<output>
After completion, create `.planning/phases/03-transpilation/03-03-SUMMARY.md`
</output>
