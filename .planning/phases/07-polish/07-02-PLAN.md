---
phase: 07-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli.ts
  - src/lib/detector.ts
  - src/lib/ui/error-formatter.ts
  - src/lib/transpiler/converter.ts
autonomous: true

must_haves:
  truths:
    - "Error messages are specific and actionable with clear resolution steps"
    - "Error messages include troubleshooting guide links"
    - "Installer exits with code 2 for partial success (some commands failed)"
    - "Installer adapts command naming based on platform filesystem limitations"
    - "Installation completes in under 10 seconds for typical GSD setup"
  artifacts:
    - path: "src/lib/ui/error-formatter.ts"
      provides: "Error formatter with actionable messages and troubleshooting links"
      min_lines: 80
      exports: ["formatError", "ErrorCategory"]
    - path: "src/cli.ts"
      provides: "CLI with exit code 2 for partial success"
      contains: "process.exit(2)"
    - path: "src/lib/detector.ts"
      provides: "Detection with enhanced error messages"
      contains: "See troubleshooting"
    - path: "src/lib/transpiler/converter.ts"
      provides: "Platform-adaptive command naming"
      contains: "filesystem limitations"
  key_links:
    - from: "src/cli.ts"
      to: "src/lib/ui/error-formatter.ts"
      via: "format errors before display"
      pattern: "formatError\\("
    - from: "src/lib/detector.ts"
      to: "src/lib/ui/error-formatter.ts"
      via: "use error formatter for detection failures"
      pattern: "formatError\\("
    - from: "src/lib/transpiler/converter.ts"
      to: "platform detection"
      via: "check platform for naming strategy"
      pattern: "process\\.platform"
---

<objective>
Enhance error handling with specific, actionable messages, add exit code differentiation for scripting, implement platform-adaptive command naming, and validate performance meets <10s requirement. This completes the UX polish by making failures informative and ensuring cross-platform reliability.

**Purpose:** Make errors helpful rather than frustrating, enable sophisticated scripting with exit codes, and ensure platform compatibility

**Output:** Error formatter with troubleshooting links, exit code 2 for partial success, platform-adaptive naming, and performance validation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish/07-CONTEXT.md

# Current error handling
@src/cli.ts
@src/lib/detector.ts

# Command naming logic
@src/lib/transpiler/converter.ts

# Package info
@package.json
</context>

<tasks>

<task type="auto">
  <name>Create error formatter with actionable messages</name>
  <files>src/lib/ui/error-formatter.ts</files>
  <action>
Create error formatter that produces specific, actionable error messages with troubleshooting links.

**Implementation requirements:**

1. **Error categories:**
```typescript
export enum ErrorCategory {
  GSD_NOT_FOUND = 'gsd_not_found',
  OPENCODE_NOT_FOUND = 'opencode_not_found',
  OPENCODE_NOT_ACCESSIBLE = 'opencode_not_accessible',
  CACHE_FAILURE = 'cache_failure',
  TRANSPILATION_FAILURE = 'transpilation_failure',
  ENHANCEMENT_FAILURE = 'enhancement_failure',
  LOG_WRITE_FAILURE = 'log_write_failure'
}

export interface FormattedError {
  message: string;
  details?: string;
  resolution: string;
  troubleshootingUrl?: string;
}

export function formatError(
  category: ErrorCategory,
  context?: Record<string, any>
): FormattedError
```

2. **Error messages by category:**

**GSD_NOT_FOUND:**
- Message: "GSD not found at ~/.claude/get-shit-done/"
- Details: (if context.checkedPaths) Show all paths checked
- Resolution: "Install GSD first: https://github.com/glittercowboy/get-shit-done"
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#gsd-not-found"

**OPENCODE_NOT_FOUND:**
- Message: "OpenCode config directory not found"
- Details: "Checked: .opencode/, ~/.config/opencode/, %APPDATA%/opencode/"
- Resolution: "Install OpenCode first or create config directory manually"
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#opencode-not-found"

**OPENCODE_NOT_ACCESSIBLE:**
- Message: "Cannot write to OpenCode config directory"
- Details: Show path and permission error
- Resolution: "Check file permissions on {path}"
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#permission-denied"

**CACHE_FAILURE:**
- Message: "Failed to cache OpenCode documentation"
- Details: Show network error or filesystem error
- Resolution: "Check network connection or disk space. Installer will continue without cached docs."
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#cache-failure"

**TRANSPILATION_FAILURE:**
- Message: "Failed to transpile {commandName}"
- Details: Show specific error (template extraction failed, invalid markdown, etc.)
- Resolution: "Check command file at {filePath} for syntax errors. See install log for details."
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#transpilation-errors"

**ENHANCEMENT_FAILURE:**
- Message: "Failed to enhance commands with /gsdo"
- Details: Show LLM error or context loading failure
- Resolution: "Commands installed but not enhanced. Run /gsdo in OpenCode manually."
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#enhancement-errors"

**LOG_WRITE_FAILURE:**
- Message: "Failed to write log to ~/.gsdo/"
- Details: Show filesystem error
- Resolution: "Check disk space and permissions. Installation succeeded despite logging failure."
- Troubleshooting: "https://github.com/[repo]/docs/troubleshooting.md#log-errors"

3. **Severity prefixes:**
   - Add "ERROR: " prefix for blocking failures
   - Add "WARNING: " prefix for non-blocking issues

4. **Use context for specifics:** When context provided, populate details with actual paths, error messages, command names.

Use placeholder repo URL for now (executor can update to actual repo).
  </action>
  <verify>
File exists and exports formatError function and ErrorCategory enum. Check error messages include resolution steps. Run: `grep -E "Resolution:" src/lib/ui/error-formatter.ts | wc -l` (should show 7+ resolutions).
  </verify>
  <done>
formatError function exists with all 7+ error categories, each having message, details, resolution, and troubleshooting URL
  </done>
</task>

<task type="auto">
  <name>Enhance detector error messages</name>
  <files>src/lib/detector.ts</files>
  <action>
Update detector to use error formatter for enhanced error messages.

**Changes required:**

1. **Import error formatter:**
```typescript
import { formatError, ErrorCategory } from './ui/error-formatter.js';
```

2. **Update detectGsd error message:**
```typescript
// Before: return { found: false, error: 'GSD not found at ...' };
// After:
const formatted = formatError(ErrorCategory.GSD_NOT_FOUND, {
  checkedPath: gsdPath
});
return {
  found: false,
  error: `${formatted.message}\n${formatted.resolution}\n${formatted.troubleshootingUrl || ''}`
};
```

3. **Update detectOpenCode error messages:**
   - Use ErrorCategory.OPENCODE_NOT_FOUND when no directories found
   - Use ErrorCategory.OPENCODE_NOT_ACCESSIBLE when directory exists but not writable
   - Include checked paths in context

4. **Keep return type unchanged:** Still return `{ found: boolean, path?: string, error?: string }`

5. **Multi-line error format:** Join message, resolution, and URL with newlines for readability
  </action>
  <verify>
detector.ts imports formatError and uses it. Check error messages include troubleshooting URLs. Run: `grep "troubleshootingUrl" src/lib/detector.ts`
  </verify>
  <done>
Detection functions use formatError to produce actionable error messages with troubleshooting links
  </done>
</task>

<task type="auto">
  <name>Add exit code 2 for partial success and integrate error formatter</name>
  <files>src/cli.ts</files>
  <action>
Add exit code differentiation and integrate error formatter throughout CLI.

**Changes required:**

1. **Import error formatter:**
```typescript
import { formatError, ErrorCategory } from './lib/ui/error-formatter.js';
```

2. **Update error handling for detection:**
```typescript
// Detection errors already include formatted messages from detector.ts
// Keep existing error display but ensure ERROR: prefix
if (!gsdResult.found) {
  console.error('ERROR:', gsdResult.error);
  process.exit(1);
}
```

3. **Update cache failure handling:**
```typescript
// When cache fails (non-blocking)
if (!cacheResult.cached) {
  const formatted = formatError(ErrorCategory.CACHE_FAILURE, {
    error: cacheResult.error
  });
  progress.log(`WARNING: ${formatted.message}`, 'warning');
  progress.log(formatted.resolution, 'info');
}
```

4. **Update enhancement failure handling:**
```typescript
catch (error) {
  const formatted = formatError(ErrorCategory.ENHANCEMENT_FAILURE, {
    error: error instanceof Error ? error.message : String(error)
  });
  progress.log(`WARNING: ${formatted.message}`, 'warning');
  progress.log(formatted.resolution, 'info');
}
```

5. **Add exit code 2 for partial success:**
```typescript
// After writing commands but before final success message
if (transpileResult.failed.length > 0) {
  // Show partial success message
  progress.log('Installation completed with failures', 'warning');
  progress.log(`See ~/.gsdo/install.log for details`, 'info');

  // Render success screen (partial variant)
  renderSuccessScreen(successData);

  // Exit with code 2 (partial success)
  process.exit(2);
}
```

6. **Exit code strategy:**
   - 0: Full success (all commands transpiled)
   - 1: Total failure (detection failed, critical error)
   - 2: Partial success (some commands failed, some succeeded)

7. **Update log write failure handling:**
```typescript
catch (logError) {
  const formatted = formatError(ErrorCategory.LOG_WRITE_FAILURE, {
    error: logError instanceof Error ? logError.message : String(logError)
  });
  progress.log(`WARNING: ${formatted.message}`, 'warning');
  // Don't exit - continue installation
}
```

Keep all existing logic intact, just enhance error display and add exit code 2.
  </action>
  <verify>
CLI compiles without errors. Check exit code 2 logic present. Run: `grep -n "process.exit(2)" src/cli.ts`. Test with failing scenario (if possible) or verify code logic.
  </verify>
  <done>
CLI uses formatError for all error categories, exits with code 2 for partial success, displays actionable error messages with troubleshooting links
  </done>
</task>

<task type="auto">
  <name>Implement platform-adaptive command naming</name>
  <files>src/lib/transpiler/converter.ts</files>
  <action>
Add platform detection to adapt command naming based on filesystem limitations.

**Implementation requirements:**

1. **Platform detection function:**
```typescript
function getPlatformNamingStrategy(): 'colon' | 'dash' {
  // Windows has stricter filesystem limitations
  // Colons in filenames are problematic on Windows
  // But OpenCode commands are JSON keys, not filenames

  // Check if we're on Windows
  if (process.platform === 'win32') {
    // Test if OpenCode config path is on filesystem that restricts colons
    // For simplicity: default to colon (OpenCode should handle it)
    return 'colon';
  }

  // Mac and Linux: prefer colon for namespace clarity
  return 'colon';
}
```

2. **Update convertCommand to use strategy:**
```typescript
export function convertCommand(gsdCommand: GsdCommand): ConversionResult {
  const namingStrategy = getPlatformNamingStrategy();

  // Convert name based on strategy
  const opencodeName = namingStrategy === 'colon'
    ? gsdCommand.name.replace(/^\/gsd:/, '/gsd:')  // Keep colon
    : gsdCommand.name.replace(/^\/gsd:/, '/gsd-'); // Replace with dash

  // Rest of conversion logic unchanged
  // ...
}
```

3. **Document reasoning:**
```typescript
/**
 * Determines command naming strategy based on platform filesystem limitations.
 *
 * OpenCode stores commands in commands.json, so command names are JSON keys,
 * not filenames. Most platforms can handle colons in JSON keys.
 *
 * Returns 'colon' to preserve /gsd: namespace clarity.
 * Falls back to 'dash' (/gsd-) only if platform truly can't handle colons.
 */
```

4. **Current behavior:** Code already uses `/gsd:` as preferred format with `/gsd-` as fallback. This task makes the decision explicit and platform-aware.

5. **No breaking changes:** Keep existing test expectations unless platform-specific.
  </action>
  <verify>
converter.ts includes platform detection logic. Run: `grep "process.platform" src/lib/transpiler/converter.ts`. Verify tests still pass: `npm test src/lib/transpiler/converter.test.ts`
  </verify>
  <done>
Command naming adapts based on platform filesystem limitations with explicit platform detection logic
  </done>
</task>

<task type="auto">
  <name>Add performance validation comment and verify <10s target</name>
  <files>src/cli.ts</files>
  <action>
Add performance measurement and validation to ensure <10s target is met.

**Changes required:**

1. **Add performance tracking at start of main():**
```typescript
async function main() {
  const startTime = Date.now();

  // Parse flags
  const forceRefresh = process.argv.includes('--force');
  // ... rest of flag parsing
```

2. **Add performance log at end (before success screen):**
```typescript
  // Before renderSuccessScreen
  const totalTime = (Date.now() - startTime) / 1000;

  if (verbosity >= VerbosityLevel.VERBOSE) {
    progress.log(`Total installation time: ${totalTime.toFixed(1)}s`, 'info');
  }

  // Performance validation (PERF-01 requirement)
  if (totalTime > 10) {
    progress.log(`WARNING: Installation took ${totalTime.toFixed(1)}s (target: <10s)`, 'warning');
  }

  renderSuccessScreen(successData);
```

3. **Add performance note in success screen data:**
Update SuccessScreenData type to include totalTime, then show in screen if >10s.

4. **Document performance expectations:**
```typescript
/**
 * Performance requirement (PERF-01): Installation must complete in <10 seconds
 * for typical GSD setup (20-30 commands).
 *
 * Typical breakdown:
 * - Detection: <0.1s
 * - Cache check: <0.5s (if fresh) or <3s (if downloading)
 * - Scanning: <0.5s
 * - Transpilation: <2s (30 commands @ ~0.06s each)
 * - Enhancement: <4s (30 commands @ ~0.13s each)
 * - Writing: <0.1s
 *
 * Total: ~6-7s typical, <10s target includes buffer for slower systems
 */
```

5. **No code changes needed if performance already meets target:** The installer is designed to be fast (async operations, caching, idempotency). This task validates and documents the requirement.
  </action>
  <verify>
CLI includes performance tracking. Run: `grep "totalTime" src/cli.ts`. Test with `npm run dev` and verify timing shown in verbose mode. Check <10s for typical setup.
  </verify>
  <done>
Performance tracking added, <10s target validated with warning if exceeded, performance expectations documented in code comments
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - compiles without errors
2. Test error scenarios:
   - Temporarily rename GSD directory to trigger GSD_NOT_FOUND error
   - Verify error message includes resolution and troubleshooting link
   - Restore GSD directory
3. Test partial success:
   - Create invalid GSD command file to trigger transpilation failure
   - Run installer and verify exit code 2: `npm run dev; echo $?` (Unix) or `npm run dev; echo %ERRORLEVEL%` (Windows)
   - Verify partial success screen shows failed count
4. Test performance:
   - Run with `--verbose` and check total time displayed
   - Verify typical installation <10s
5. Test platform naming:
   - Verify commands use /gsd: format (or /gsd- if platform requires)
6. Run full test suite: `npm test`
</verification>

<success_criteria>
- [ ] Error messages are specific with resolution steps and troubleshooting URLs
- [ ] Exit code 2 for partial success (some commands failed)
- [ ] Exit code 1 for total failure (detection failed)
- [ ] Exit code 0 for full success
- [ ] Platform-adaptive command naming logic in place
- [ ] Performance validated - typical installation <10s
- [ ] Performance warning shows if >10s
- [ ] All tests pass
- [ ] All Phase 7 requirements (UX-01 through UX-07, PERF-01, PLATFORM-04) complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish/07-02-SUMMARY.md`
</output>
