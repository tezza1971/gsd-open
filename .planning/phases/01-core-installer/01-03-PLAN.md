---
phase: 01-core-installer
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - src/lib/installer/commands-manager.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "Installer reads existing OpenCode commands.json if present"
    - "Installer adds transpiled commands without breaking existing commands"
    - "Installer writes updated commands.json to OpenCode config directory"
    - "User can run installer end-to-end via CLI entry point"
  artifacts:
    - path: "src/lib/installer/commands-manager.ts"
      provides: "Safe read/write operations for OpenCode commands.json"
      exports: ["readCommands", "writeCommands", "mergeCommands"]
      min_lines: 60
    - path: "src/cli.ts"
      provides: "CLI entry point that orchestrates detection, transpilation, installation"
      exports: []
      min_lines: 80
  key_links:
    - from: "src/lib/installer/commands-manager.ts"
      to: "fs"
      via: "reads/writes commands.json safely"
      pattern: "readFileSync|writeFileSync"
    - from: "src/cli.ts"
      to: "src/lib/detector.ts"
      via: "calls detectGsd and detectOpenCode"
      pattern: "detectGsd|detectOpenCode"
    - from: "src/cli.ts"
      to: "src/lib/transpiler/scanner.ts"
      via: "scans GSD commands"
      pattern: "scanGsdCommands"
    - from: "src/cli.ts"
      to: "src/lib/transpiler/converter.ts"
      via: "converts commands"
      pattern: "convertBatch"
    - from: "src/cli.ts"
      to: "src/lib/installer/commands-manager.ts"
      via: "writes to OpenCode"
      pattern: "writeCommands"
---

<objective>
Create OpenCode integration layer and CLI orchestrator that safely writes transpiled commands.

Purpose: Completes the end-to-end flow from detection → transpilation → installation. Ensures existing OpenCode commands are preserved during merge.
Output: Commands manager that safely updates commands.json + CLI that runs full installer flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@gsdo-spec.md
@package.json
@.planning/phases/01-core-installer/01-01-SUMMARY.md
@.planning/phases/01-core-installer/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create commands.json manager</name>
  <files>src/lib/installer/commands-manager.ts</files>
  <action>
Create `src/lib/installer/commands-manager.ts` for safe OpenCode commands.json operations.

Implement:
- `readCommands(opencodePath: string): OpenCodeCommand[]`
  - Construct path: `${opencodePath}/commands.json`
  - Check if file exists using `fs.existsSync()`
  - If exists, read with `fs.readFileSync()` and parse JSON
  - If doesn't exist, return empty array `[]`
  - If JSON parse fails, throw error with clear message
  - Return array of existing commands

- `mergeCommands(existing: OpenCodeCommand[], newCommands: OpenCodeCommand[]): OpenCodeCommand[]`
  - Create Map from existing commands (key: command.name)
  - For each new command: if name exists in map, replace; else add
  - Return merged array
  - Preserve order: existing commands first (updated in place), then new commands appended

- `writeCommands(opencodePath: string, commands: OpenCodeCommand[]): void`
  - Construct path: `${opencodePath}/commands.json`
  - Stringify JSON with 2-space indentation: `JSON.stringify(commands, null, 2)`
  - Write using `fs.writeFileSync(filePath, json, 'utf-8')`
  - No backup/rollback - overwrite strategy per project requirements

Import `OpenCodeCommand` from `../transpiler/types.ts`. Use Node.js `fs`, `path` modules only.
  </action>
  <verify>
Build succeeds: `npm run build`
All three functions exported with correct types
Merge logic preserves existing commands and adds new ones
  </verify>
  <done>
Commands manager exists with safe read/write/merge operations for OpenCode commands.json.
  </done>
</task>

<task type="auto">
  <name>Create CLI orchestrator</name>
  <files>src/cli.ts</files>
  <action>
Create `src/cli.ts` as the main entry point that orchestrates the full installer flow.

Implement main flow:
```typescript
#!/usr/bin/env node

import { detectGsd, detectOpenCode } from './lib/detector.js';
import { scanGsdCommands } from './lib/transpiler/scanner.js';
import { convertBatch } from './lib/transpiler/converter.js';
import { readCommands, mergeCommands, writeCommands } from './lib/installer/commands-manager.js';

async function main() {
  console.log('→ Detecting GSD installation...');
  const gsdResult = detectGsd();
  if (!gsdResult.found) {
    console.error('✗', gsdResult.error);
    process.exit(1);
  }
  console.log('  ✓ Found at', gsdResult.path);

  console.log('→ Detecting OpenCode installation...');
  const opencodeResult = detectOpenCode();
  if (!opencodeResult.found) {
    console.error('✗', opencodeResult.error);
    process.exit(1);
  }
  console.log('  ✓', opencodeResult.created ? 'Created at' : 'Found at', opencodeResult.path);

  console.log('→ Scanning for /gsd:* commands...');
  const gsdCommands = scanGsdCommands(gsdResult.path!);
  console.log(`  ✓ Found ${gsdCommands.length} commands`);

  console.log('→ Transpiling commands...');
  const transpileResult = convertBatch(gsdCommands);
  console.log(`  ✓ ${transpileResult.successful.length} successful`);
  if (transpileResult.failed.length > 0) {
    console.log(`  ⚠ ${transpileResult.failed.length} failed`);
  }

  console.log('→ Writing to OpenCode...');
  const existingCommands = readCommands(opencodeResult.path!);
  const mergedCommands = mergeCommands(existingCommands, transpileResult.successful);
  writeCommands(opencodeResult.path!, mergedCommands);
  console.log(`  ✓ ${opencodeResult.path}/commands.json updated`);

  console.log('\n✓ Installation complete');
}

main().catch(err => {
  console.error('ERROR:', err.message);
  process.exit(1);
});
```

Use simple console.log for output (Phase 7 will add ASCII art). Exit codes: 0 for success, 1 for errors.
Shebang `#!/usr/bin/env node` at top for npx execution.
  </action>
  <verify>
Build succeeds: `npm run build`
CLI imports all required modules
Exit codes are correct (1 for errors, 0 for success)
Check dist/cli.js has shebang and is executable
  </verify>
  <done>
CLI entry point exists that orchestrates detection → scanning → transpilation → installation flow with console output.
  </done>
</task>

<task type="auto">
  <name>Add integration test</name>
  <files>src/integration.test.ts</files>
  <action>
Create `src/integration.test.ts` to verify end-to-end flow (as much as testable without actual GSD installation).

Test scenarios:
- Mock filesystem with fake GSD directory structure
- Verify scanner finds markdown files
- Verify converter produces OpenCode commands
- Verify merge logic preserves existing commands
- Verify writeCommands creates valid JSON

Use Vitest mocking capabilities to simulate filesystem. Don't require actual GSD installation.

Keep test simple - focus on happy path verification. Error paths can be tested in Phase 7.
  </action>
  <verify>
Tests pass: `npm test`
Integration test covers main flow
  </verify>
  <done>
Integration test verifies end-to-end installer flow works correctly.
  </done>
</task>

</tasks>

<verification>
Run `npm run build` - build produces executable dist/cli.js
Run `npm test` - all tests pass including integration test
Check dist/cli.js has correct shebang: `#!/usr/bin/env node`
Verify package.json bin points to dist/cli.js
Test CLI manually if possible: `node dist/cli.js` (will fail without GSD, but should show detection error)
</verification>

<success_criteria>
OpenCode integration is complete when:
- [ ] Commands manager reads existing commands.json safely (handles missing file)
- [ ] Commands manager merges new commands with existing (preserves both)
- [ ] Commands manager writes valid JSON with proper formatting
- [ ] CLI orchestrates full flow: detect → scan → convert → merge → write
- [ ] CLI exits with code 1 on errors, 0 on success
- [ ] CLI shows progress output for each step
- [ ] Build produces executable CLI with correct shebang
- [ ] Integration test verifies happy path works
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-installer/01-03-SUMMARY.md`
</output>
