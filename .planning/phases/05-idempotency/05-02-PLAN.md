---
phase: 05-idempotency
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/idempotency/freshness-checker.ts
  - src/lib/idempotency/freshness-checker.test.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "Installer skips re-transpilation when no GSD files have changed"
    - "Installer shows 'Already up to date' message when skipping"
    - "Installer re-transpiles when any skill file is added, deleted, or modified"
    - "Installer supports --force flag to bypass freshness checks"
    - "Installer updates state file after successful transpilation"
  artifacts:
    - path: "src/lib/idempotency/freshness-checker.ts"
      provides: "Logic to compare previous vs current state"
      exports: ["checkFreshness", "FreshnessResult"]
      min_lines: 60
    - path: "src/lib/idempotency/freshness-checker.test.ts"
      provides: "Test coverage for freshness detection"
      min_lines: 80
    - path: "src/cli.ts"
      provides: "Updated main flow with idempotency checks"
      min_lines: 200
  key_links:
    - from: "src/cli.ts"
      to: "freshness-checker.ts"
      via: "import { checkFreshness }"
      pattern: "checkFreshness.*ImportState"
    - from: "src/cli.ts"
      to: "state-manager.ts"
      via: "readImportState() before scan, writeImportState() after success"
      pattern: "readImportState|writeImportState"
---

<objective>
Integrate idempotency checks into CLI to skip redundant transpilation.

Purpose: Make repeated installer runs fast by detecting when GSD source hasn't changed, improving developer experience during iterative work.

Output: CLI that checks freshness, skips work when appropriate, supports --force flag, and updates state after successful runs.
</objective>

<execution_context>
@C:/Users/Terence/code/gsd-open/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Terence/code/gsd-open/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Terence/code/gsd-open/.planning/PROJECT.md
@C:/Users/Terence/code/gsd-open/.planning/ROADMAP.md
@C:/Users/Terence/code/gsd-open/.planning/STATE.md
@C:/Users/Terence/code/gsd-open/.planning/phases/05-idempotency/05-CONTEXT.md
@C:/Users/Terence/code/gsd-open/.planning/phases/05-idempotency/05-01-SUMMARY.md

# Current CLI implementation
@C:/Users/Terence/code/gsd-open/src/cli.ts

# State management from previous plan
@C:/Users/Terence/code/gsd-open/src/lib/idempotency/state-manager.ts
@C:/Users/Terence/code/gsd-open/src/lib/idempotency/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create freshness checker logic</name>
  <files>
    src/lib/idempotency/freshness-checker.ts
    src/lib/idempotency/freshness-checker.test.ts
  </files>
  <action>
Create freshness detection logic:

**freshness-checker.ts:**
- `FreshnessResult` type: `{ fresh: boolean, reason?: string }`
  - `fresh: true` = no changes, skip transpilation
  - `fresh: false` + reason = why re-transpilation needed

- `checkFreshness(previous: ImportState | null, current: ImportState): FreshnessResult`
  - If `previous === null`, return `{ fresh: false, reason: "First run" }`
  - If `previous.skills.length !== current.skills.length`, return `{ fresh: false, reason: "File count changed (X -> Y)" }`
  - Compare each skill file:
    - Build Map from `previous.skills` (path -> mtime)
    - For each file in `current.skills`:
      - If path not in Map, return `{ fresh: false, reason: "New file: {path}" }`
      - If mtime different, return `{ fresh: false, reason: "Modified: {path}" }`
    - For each file in `previous.skills`:
      - If path not in `current.skills`, return `{ fresh: false, reason: "Deleted: {path}" }`
  - If all checks pass, return `{ fresh: true }`

**freshness-checker.test.ts:**
- Test first run (null previous) returns fresh: false
- Test identical state returns fresh: true
- Test file count change detected (addition)
- Test file count change detected (deletion)
- Test mtime change detected (modification)
- Test new file detected even with same count (file replaced)
- Test deleted file detected

Follow existing testing patterns from cache/manager.test.ts.
  </action>
  <verify>
npm test -- freshness-checker.test.ts
  </verify>
  <done>
All tests pass. Freshness checker accurately detects file additions, deletions, and modifications.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate idempotency into CLI</name>
  <files>
    src/cli.ts
  </files>
  <action>
Update CLI to support idempotency:

**Parse --force flag:**
- After imports, check `process.argv.includes('--force')`
- Store in `const forceRefresh = process.argv.includes('--force')`

**Add freshness check before scanning:**
After GSD detection succeeds, before "Scanning for /gsd:* commands":

```typescript
// Check if re-transpilation needed
console.log('→ Checking for changes...');

const previousState = readImportState();
const currentState = buildCurrentState(gsdResult.path!);
const freshness = checkFreshness(previousState, currentState);

if (!forceRefresh && freshness.fresh) {
  console.log('  ✓ GSD files unchanged since last import');
  console.log('  ✓ Already up to date');
  console.log('');
  console.log('Tip: Run with --force to re-transpile anyway');

  // Still check docs cache freshness independently
  const cacheResult = await ensureOpenCodeDocsCache();
  if (cacheResult.cached && !cacheResult.stale) {
    console.log('  ✓ Documentation cache fresh');
  } else if (cacheResult.stale) {
    console.log('  ⚠ Documentation cache refreshed');
  }

  process.exit(0); // Success - nothing to do
}

if (forceRefresh) {
  console.log('  → Forcing re-transpilation (--force flag)');
} else {
  console.log(`  → Changes detected: ${freshness.reason}`);
}
```

**Update state after successful installation:**
After the final success message, before process.exit(0):

```typescript
// Update import state for next run
const finalState = buildCurrentState(gsdResult.path!);

// Update docs cache timestamp from cache manager
const cacheDir = getDocsOpenCodeCachePath();
const metadataPath = join(cacheDir, 'metadata.json');
if (existsSync(metadataPath)) {
  const metadataContent = await readFile(metadataPath, 'utf-8');
  const metadata = JSON.parse(metadataContent);
  finalState.docsCachedAt = metadata.downloadedAt;
}

writeImportState(finalState);
```

**Import additions needed:**
- `import { readImportState, writeImportState, buildCurrentState } from './lib/idempotency/state-manager.js'`
- `import { checkFreshness } from './lib/idempotency/freshness-checker.js'`
- `import { getDocsOpenCodeCachePath } from './lib/cache/paths.js'` (if not already imported)
- `import { existsSync } from 'node:fs'`
- `import { readFile } from 'node:fs/promises'`
- `import { join } from 'node:path'`

Maintain existing CLI output patterns (→ for steps, ✓ for success, ⚠ for warnings).
  </action>
  <verify>
# Run installer twice to verify skip behavior
npm run dev
npm run dev  # Should show "Already up to date"

# Test --force flag
npm run dev -- --force  # Should re-transpile despite no changes
  </verify>
  <done>
Installer skips work when no changes detected, shows clear messaging, and supports --force flag for manual refresh. State file updated after successful runs.
  </done>
</task>

</tasks>

<verification>
- [ ] First run transpiles normally and creates state file
- [ ] Second run with no changes shows "Already up to date" and exits immediately
- [ ] Modifying a skill file triggers re-transpilation
- [ ] Adding a new skill file triggers re-transpilation
- [ ] Deleting a skill file triggers re-transpilation
- [ ] --force flag bypasses freshness check and re-transpiles
- [ ] State file updated with current timestamps after successful run
- [ ] Docs cache freshness checked independently during skip
</verification>

<success_criteria>
Installer implements full idempotency with file-level change detection, clear user messaging, and force refresh capability. Repeated runs are fast when source unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/05-idempotency/05-02-SUMMARY.md`
</output>
